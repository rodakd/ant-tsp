var P=Object.defineProperty;var y=(c,n,i)=>n in c?P(c,n,{enumerable:!0,configurable:!0,writable:!0,value:i}):c[n]=i;var a=(c,n,i)=>(y(c,typeof n!="symbol"?n+"":n,i),i);(function(){"use strict";const i=(e,t)=>{const[s,r]=e,[p,h]=t;if(r===h&&s===p)return 0;const d=Math.PI*r/180,l=Math.PI*h/180,M=s-p,E=Math.PI*M/180;let o=Math.sin(d)*Math.sin(l)+Math.cos(d)*Math.cos(l)*Math.cos(E);return o>1&&(o=1),o=Math.acos(o),o=o*180/Math.PI,o*60*1.1515*1.609344},m=e=>e!=null&&e.length?e.slice(0,-1).map((t,s)=>i(t,e[s+1])).reduce((t,s)=>t+s,0):0,g=e=>{let t=new u;onmessage=async s=>{var p;if(postMessage({type:"log",toLog:"lol"}),!((p=s==null?void 0:s.data)!=null&&p.type))return;const r=s.data;switch(r.type){case"run":t=new u,t.params=r.params,t.markers=r.markers,t.speedPercent=r.speedPercent,t.performanceMode=r.performanceMode,t.iterationsLimit=r.iterationsLimit,e(t,r.params).catch(()=>null);break;case"stop":t.running=!1;break;case"pause":t.paused=!0;break;case"resume":t.paused=!1;break;case"changeSpeed":t.speedPercent=r.speedPercent}}};class u{constructor(){a(this,"paused",!1);a(this,"running",!0);a(this,"bestTour",null);a(this,"currentTour",null);a(this,"iteration",0);a(this,"markers",[]);a(this,"params",{});a(this,"speedPercent",60);a(this,"performanceMode",!1);a(this,"iterationsLimit",null)}updateBestTour(t){this.bestTour=t,this.appDispatch({type:"updateBestTour",bestTour:t})}updateIteration(t){if(this.iteration=t,this.iterationsLimit&&this.iteration>this.iterationsLimit)return this.end();this.appDispatch({type:"updateIteration",iteration:t})}updateCurrentTour(t){this.currentTour=t,this.appDispatch({type:"updateCurrentTour",currentTour:t})}async sleep(){return new Promise(t=>{if(!this.running)throw"Stopped";if(this.performanceMode)return t();for(;this.paused&&this.running;)return setTimeout(t,200);const s=500-this.speedPercent/100*500;return setTimeout(t,s)})}log(t){this.appDispatch({type:"log",toLog:JSON.stringify(t)})}error(t){this.appDispatch({type:"error",text:t})}calculateCost(t){return m(t)}end(){throw this.appDispatch({type:"end"}),this.running=!1,"Stopped"}appDispatch(t){if(!this.running)throw"Stopped";postMessage(t)}}async function f(e){for(;e.running;)e.updateIteration(e.iteration+1),await e.sleep()}g(f)})();
